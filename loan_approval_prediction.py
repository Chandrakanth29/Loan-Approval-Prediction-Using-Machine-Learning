# -*- coding: utf-8 -*-
"""Loan Approval Prediction

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1MDNEnaiKfP36KW2GVbfWz_yP4zIW2JSW

# **Loan Approval Prediction Using Machine Learning** **(End-to-End Project)**

# üî∞ Introduction
### **In this project, I aim to predict whether a loan application will be approved or not using historical loan data.**
### **I will use supervised machine learning techniques, mainly Random Forest Classifier, to build an end-to-end predictive model.**

---

### **Step 1:** **Importing Required Libraries**

### üìù This step loads all the libraries required for data manipulation, visualization, and model building.
"""

import pandas as pd
import numpy as np
import seaborn as sns
import matplotlib.pyplot as plt
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import LabelEncoder
from sklearn.ensemble import RandomForestClassifier
from sklearn.metrics import accuracy_score, confusion_matrix, classification_report

"""---

### **Step 2:** **Loading the Dataset**

### üìù We load the training and test datasets to start exploring and cleaning the data.
"""

train_df = pd.read_csv('/content/train.csv')
test_df = pd.read_csv('/content/test.csv')

# Preview data
train_df.head()

"""---

### **Step 3:** **Data Exploration & Understanding**

### üìù  Understand the structure of the dataset, types of columns, and missing values.
"""

# Check shape and info
print(train_df.shape)
print(train_df.info())

# Check for missing values
train_df.isnull().sum()
test_df.isnull().sum()

"""---

### **Step 4:** **Handle Missing Values**

### üìù   Fill missing data using mode and median so the model can train on clean data.
"""

# Fill missing values in train_df
train_df['Gender'].fillna(train_df['Gender'].mode()[0], inplace=True)
train_df['Married'].fillna(train_df['Married'].mode()[0], inplace=True)
train_df['Dependents'].fillna(train_df['Dependents'].mode()[0], inplace=True)
train_df['Self_Employed'].fillna(train_df['Self_Employed'].mode()[0], inplace=True)
train_df['LoanAmount'].fillna(train_df['LoanAmount'].median(), inplace=True)
train_df['Loan_Amount_Term'].fillna(train_df['Loan_Amount_Term'].mode()[0], inplace=True)
train_df['Credit_History'].fillna(train_df['Credit_History'].mode()[0], inplace=True)

# Same for test_df
test_df['Gender'].fillna(test_df['Gender'].mode()[0], inplace=True)
test_df['Married'].fillna(test_df['Married'].mode()[0], inplace=True)
test_df['Dependents'].fillna(test_df['Dependents'].mode()[0], inplace=True)
test_df['Self_Employed'].fillna(test_df['Self_Employed'].mode()[0], inplace=True)
test_df['LoanAmount'].fillna(test_df['LoanAmount'].median(), inplace=True)
test_df['Loan_Amount_Term'].fillna(test_df['Loan_Amount_Term'].mode()[0], inplace=True)
test_df['Credit_History'].fillna(test_df['Credit_History'].mode()[0], inplace=True)

"""---

### **Step 5:** **Encode Categorical Variables**

### üìù   Machine learning models require numeric input, so we convert text columns to numbers.
"""

# Replace '3+' with 3
train_df['Dependents'].replace('3+', 3, inplace=True)
test_df['Dependents'].replace('3+', 3, inplace=True)

# Convert to numeric
train_df['Dependents'] = train_df['Dependents'].astype(int)
test_df['Dependents'] = test_df['Dependents'].astype(int)

# Label encoding
cols = ['Gender', 'Married', 'Education', 'Self_Employed', 'Property_Area']
le = LabelEncoder()
for col in cols:
    train_df[col] = le.fit_transform(train_df[col])
    test_df[col] = le.transform(test_df[col])

# Encode target variable
train_df['Loan_Status'] = train_df['Loan_Status'].map({'Y': 1, 'N': 0})

"""---

### **Step 6:** **Feature Selection**

### üìù   Define features (X) and the target variable (y) for model training.
"""

X = train_df.drop(['Loan_ID', 'Loan_Status'], axis=1)
y = train_df['Loan_Status']

"""---

### **Step 7:** **Train-Test Split**
### üìù   Split the training data for model evaluation using a hold-out set.
"""

X_train, X_valid, y_train, y_valid = train_test_split(X, y, test_size=0.2, random_state=42)

"""---

### **Step 8:** **Model Training (Random Forest Classifier)**
### üìù   Train the model on historical data to learn patterns.
"""

model = RandomForestClassifier()
model.fit(X_train, y_train)

# Predict on validation set
y_pred = model.predict(X_valid)

# Evaluation
print("Accuracy:", accuracy_score(y_valid, y_pred))
print(confusion_matrix(y_valid, y_pred))
print(classification_report(y_valid, y_pred))

"""---

### **Step 9:**  **Predict on Final Test Data**
### üìù   Make predictions on new, unseen applications and export them as a CSV file.
"""

# Drop Loan_ID from test
X_test_final = test_df.drop('Loan_ID', axis=1)

# Predict
test_pred = model.predict(X_test_final)

# Convert to 'Y'/'N'
test_pred = ['Y' if val == 1 else 'N' for val in test_pred]

# Save results
submission = pd.DataFrame({
    'Loan_ID': test_df['Loan_ID'],
    'Loan_Status': test_pred
})

submission.to_csv('Loan_Status_Predictions.csv', index=False)
submission.head()

"""---

### **Step 10:**  **Feature Importance Ranking**
### üìù   This horizontal bar chart displays the relative importance of each feature used in the machine learning model for predicting loan approval.
"""

feat_importance = pd.Series(model.feature_importances_, index=X.columns)
feat_importance.sort_values().plot(kind='barh', title='Feature Importance')
plt.show()

"""---

# üìà **Data Visualization Plots**

## üî∞ To analyze factors influencing loan approval decisions using exploratory data analysis and visualizations to identify key patterns and relationships in the dataset.

---

## 1. Loan Status Count (Target Balance)
### This bar chart displays the frequency of approved vs rejected loans, helping identify class imbalance in the target variable. Understanding the target distribution is crucial for model selection and evaluation metrics.
"""

sns.countplot(x='Loan_Status', data=train_df)
plt.title('Loan Status Distribution')
plt.xticks([0, 1], ['Rejected (N)', 'Approved (Y)'])
plt.ylabel('Count')
plt.show()

"""---

## 2. Gender vs Loan Approval
### This visualization compares loan approval rates between male and female applicants, revealing potential gender-based patterns in lending decisions.
"""

sns.countplot(x='Gender', hue='Loan_Status', data=train_df)
plt.title('Loan Approval Status by Gender')
plt.xticks([0, 1], ['Female', 'Male'])
plt.ylabel('Count')
plt.show()

"""---

## 3. Education vs Loan Approval
### This chart compares approval rates between graduates and non-graduates, showing how education level influences lending decisions.
"""

sns.countplot(x='Education', hue='Loan_Status', data=train_df)
plt.title('Loan Approval Status by Education')
plt.xticks([0, 1], ['Graduate', 'Not Graduate'])
plt.ylabel('Count')
plt.show()

"""---

## 4. Property Area vs Loan Approval
### This visualization examines how property location (Rural, Semi-urban, Urban) affects loan approval rates, indicating geographic lending preferences.
"""

sns.countplot(x='Property_Area', hue='Loan_Status', data=train_df)
plt.title('Loan Approval by Property Area')
plt.xticks([0, 1, 2], ['Rural', 'Semiurban', 'Urban'])
plt.ylabel('Count')
plt.show()

"""---

## 5. Applicant Income vs Loan Status
### This boxplot reveals income patterns for approved vs rejected loans, showing median income, quartiles, and outliers for each category.
"""

sns.boxplot(x='Loan_Status', y='ApplicantIncome', data=train_df)
plt.title('Applicant Income by Loan Status')
plt.xticks([0, 1], ['Rejected', 'Approved'])
plt.show()

"""---

## 6. Correlation Heatmap
### This correlation matrix shows the strength and direction of linear relationships between variables, helping identify multicollinearity and feature relationships.
"""

import seaborn as sns
import matplotlib.pyplot as plt

plt.figure(figsize=(10,6))
# Drop the 'Loan_ID' column before calculating the correlation matrix
corr_matrix = train_df.drop('Loan_ID', axis=1).corr()
sns.heatmap(corr_matrix, annot=True, cmap='coolwarm', fmt='.2f')
plt.title('Correlation Matrix')
plt.show()

"""---

## 7. Pair Plot
### This comprehensive visualization shows scatter plots for all variable pairs, colored by loan status, revealing complex multivariate relationships.
"""

sns.pairplot(train_df[['ApplicantIncome', 'CoapplicantIncome', 'LoanAmount', 'Loan_Amount_Term', 'Credit_History', 'Loan_Status']], hue='Loan_Status')
plt.show()

"""---

# ‚úÖ **Conclusion**

## In this project, I built a Loan Approval Prediction model using the Random Forest Classifier.
## I cleaned the data, visualized key insights, encoded categorical variables, and trained a machine learning model that achieved good accuracy on the validation set.

## Then I applied this model to predict loan approval statuses for new applications.

## This project showcases real-world ML workflows: data preprocessing, model building, and inference on new data ‚Äî ideal for job portfolios or demonstrating end-to-end ML proficiency.

---
"""